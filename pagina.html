<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>César Aarón | Computer Scientist</title>
    <style>
        :root {
            --primary-pink: #ffcccb;
            --bg-color: #050505;
            --text-font: 'Courier New', monospace;
        }

        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: var(--bg-color); font-family: var(--text-font); }

        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }

        .ui-layer {
            position: relative; z-index: 10; pointer-events: none;
            height: 100vh; display: flex; align-items: center; justify-content: space-between; padding: 0 10%; color: var(--primary-pink);
        }

        nav { position: absolute; top: 20px; width: 80%; display: flex; justify-content: space-between; font-size: 0.8rem; letter-spacing: 2px; }
        .nav-links span { margin-left: 20px; cursor: pointer; pointer-events: auto; transition: text-shadow 0.3s; }
        .nav-links span:hover { text-shadow: 0 0 10px var(--primary-pink); }

        .hero-text { max-width: 50%; }
        h1 { font-size: 3.5rem; line-height: 1.1; margin-bottom: 10px; font-weight: 300; text-transform: uppercase; text-shadow: 0 0 20px rgba(255, 204, 203, 0.3); }
        h2 { font-size: 1rem; opacity: 0.8; letter-spacing: 4px; border-left: 3px solid var(--primary-pink); padding-left: 15px; }

        .logo-icon { width: 50px; height: 50px; border: 2px solid var(--primary-pink); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: 20px; font-size: 20px; box-shadow: 0 0 15px rgba(255, 204, 203, 0.2); }

        .profile-container {
            position: relative; width: 350px; height: 350px; pointer-events: auto;
            border-radius: 50%;
            background: rgba(255, 204, 203, 0.02);
            backdrop-filter: blur(2px);
            border: 1px solid rgba(255, 204, 203, 0.2);
            box-shadow: 0 0 30px rgba(255, 204, 203, 0.05);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
            transition: transform 0.1s;
        }

        .profile-img {
            width: 90%; height: 90%; border-radius: 50%; object-fit: cover;
            filter: sepia(20%) hue-rotate(-50deg) contrast(1.1);
        }

        .scroll-indicator { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); font-size: 2rem; animation: bounce 2s infinite; }
        @keyframes bounce { 0%, 100% { transform: translate(-50%, 0); opacity: 0.5; } 50% { transform: translate(-50%, 10px); opacity: 1; } }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="ui-layer">
        <nav>
            <div>COMPUTER SCIENTIST | WEB DEVELOPER</div>
            <div class="nav-links">
                <span>PROJECTS</span>
                <span>EXPERIENCE</span>
                <span>CONTACT_ME</span>
                <span>CSV</span>
            </div>
        </nav>

        <div class="hero-text">
            <div class="logo-icon">ヅ</div>
            <h1>César Aarón<br>Perales Rosales</h1>
            <h2>WEB DEVELOPER | SYSTEM ARCHITECT</h2>
        </div>

        <div class="profile-container" id="profile">
            <img src="https://via.placeholder.com/400" alt="César Perales" class="profile-img">
        </div>
        <div class="scroll-indicator">↓</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- VARIABLES GLOBALES DE SIMULACIÓN ---
        // Ya no son constantes fijas, cambiarán según la pantalla
        let SIM_WIDTH = 256;
        let SIM_HEIGHT = 256;
        const DAMPING = 0.95;

        let buffer1, buffer2; // Arrays dinámicos
        let dataTexture;      // Textura dinámica

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // --- INICIALIZACIÓN DE LA GRID DINÁMICA ---
        function initSimulation() {
            // 1. Calcular Aspect Ratio
            const aspect = window.innerWidth / window.innerHeight;

            // 2. Definir resolución base vertical y calcular la horizontal
            // Esto asegura que las celdas de la grid sean CUADRADAS visualmente
            const baseHeight = 120; // Resolución vertical de la física
            SIM_HEIGHT = baseHeight;
            SIM_WIDTH = Math.floor(baseHeight * aspect);

            // 3. Crear Buffers con el nuevo tamaño
            buffer1 = new Float32Array(SIM_WIDTH * SIM_HEIGHT);
            buffer2 = new Float32Array(SIM_WIDTH * SIM_HEIGHT);

            // 4. Crear o Actualizar Textura
            if (dataTexture) {
                dataTexture.dispose(); // Limpiar memoria anterior
            }

            dataTexture = new THREE.DataTexture(
                buffer1, SIM_WIDTH, SIM_HEIGHT, THREE.RedFormat, THREE.FloatType
            );
            dataTexture.minFilter = THREE.LinearFilter;
            dataTexture.magFilter = THREE.LinearFilter;
            dataTexture.needsUpdate = true;

            // 5. Actualizar Uniforms si ya existen
            if (uniforms) {
                uniforms.u_displacementMap.value = dataTexture;
                uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
            }
        }

        // Llamamos a la inicialización por primera vez
        let uniforms = {
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            u_displacementMap: { value: null }, // Se llena en initSimulation
            u_color_base: { value: new THREE.Color(0.015, 0.01, 0.015) },
            u_color_fluid: { value: new THREE.Color(0.99, 0.73, 0.78) }
        };

        initSimulation();

        // --- SHADER ---
        const fragmentShader = `
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform sampler2D u_displacementMap;
            uniform vec3 u_color_base;
            uniform vec3 u_color_fluid;

            float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise (in vec2 _st) {
                vec2 i = floor(_st); vec2 f = fract(_st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            #define NUM_OCTAVES 5
            float fbm ( in vec2 _st) {
                float v = 0.0; float a = 0.5; vec2 shift = vec2(100.0);
                mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                for (int i = 0; i < NUM_OCTAVES; ++i) {
                    v += a * noise(_st); _st = rot * _st * 2.0 + shift; a *= 0.5;
                }
                return v;
            }

            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution.xy;

                // LEER FÍSICA
                // Como hemos ajustado el tamaño de la textura al tamaño de la pantalla,
                // podemos mapear st (0..1) directamente y el círculo será redondo.
                float waveHeight = texture2D(u_displacementMap, st).r;

                // DISTORSIÓN
                vec2 displacement = vec2(waveHeight) * 0.08;
                vec2 distortedST = st - displacement;

                // Corrección de aspecto SOLO para el dibujo del ruido (nubes)
                // Para la física ya no es necesario corregir porque la grid misma tiene el aspecto correcto.
                vec2 aspectST = distortedST;
                aspectST.x *= u_resolution.x / u_resolution.y;

                // GENERAR HUMO
                vec2 q = vec2(0.);
                q.x = fbm( aspectST + 0.02 * u_time);
                q.y = fbm( aspectST + vec2(1.0));

                vec2 r = vec2(0.);
                r.x = fbm( aspectST + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);
                r.y = fbm( aspectST + 1.0 * q + vec2(8.3, 2.8) + 0.126 * u_time);

                float smokeIntensity = fbm(aspectST + r);

                // COLOR - Ajustado para ser más sutil y transparente
                // Elevamos a potencia 3.0 para borrar los grises y dejar solo blancos altos
                // Multiplicamos por 0.5 para bajar la opacidad general
                float finalIntensity = pow(smokeIntensity, 3.0) * 0.5;

                vec3 color = mix(u_color_base, u_color_fluid, clamp(finalIntensity, 0.0, 1.0));

                // Brillo de la onda física (Sutil)
                color += u_color_fluid * smoothstep(0.05, 0.6, waveHeight) * 0.1;

                // Viñeta
                float vignette = 1.0 - smoothstep(0.5, 1.5, length(gl_FragCoord.xy / u_resolution.xy - 0.5));
                color *= vignette;

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `void main() { gl_Position = vec4( position, 1.0 ); }`,
            fragmentShader: fragmentShader
        });
        scene.add(new THREE.Mesh(geometry, material));

        // --- LÓGICA DE FÍSICA (Adaptada a Grid Dinámica) ---
        function addDisturbance(x, y, strength) {
            // Mapeamos coordenada de pantalla (0..1) a dimensiones de la grid (0..SIM_WIDTH)
            let gx = Math.floor(x * SIM_WIDTH);
            let gy = Math.floor((1.0 - y) * SIM_HEIGHT);

            if (gx > 2 && gx < SIM_WIDTH - 3 && gy > 2 && gy < SIM_HEIGHT - 3) {
                const radius = 3;
                for(let i = -radius; i <= radius; i++) {
                    for(let j = -radius; j <= radius; j++) {
                        let dist = Math.sqrt(i*i + j*j);
                        if (dist <= radius) {
                             // Cálculo de índice seguro usando SIM_WIDTH actual
                             const index = (gx + i) + (gy + j) * SIM_WIDTH;
                             buffer1[index] += strength * (Math.cos(dist / radius * Math.PI / 2));
                        }
                    }
                }
            }
        }

        function updatePhysics() {
            // Recorremos la grid usando las dimensiones dinámicas
            for (let y = 1; y < SIM_HEIGHT - 1; y++) {
                for (let x = 1; x < SIM_WIDTH - 1; x++) {
                    const i = x + y * SIM_WIDTH;

                    // Algoritmo de ondas
                    let val = (
                        buffer1[i - 1] +
                        buffer1[i + 1] +
                        buffer1[i - SIM_WIDTH] + // Vecino Arriba
                        buffer1[i + SIM_WIDTH]   // Vecino Abajo
                    ) / 2;

                    val -= buffer2[i];
                    val *= DAMPING;
                    buffer2[i] = val;
                }
            }

            // Swap buffers
            let temp = buffer1; buffer1 = buffer2; buffer2 = temp;

            // Actualizar textura
            dataTexture.image.data = buffer1;
            dataTexture.needsUpdate = true;
        }

        // --- MANEJO DE EVENTOS ---

        // Resize: Recalcula TODA la simulación para mantener celdas cuadradas
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            initSimulation(); // <--- Aquí ocurre la magia de la adaptación
        });

        let prevMouseX = 0, prevMouseY = 0;
        document.addEventListener('mousemove', (e) => {
            const x = e.clientX / window.innerWidth;
            const y = e.clientY / window.innerHeight;

            // Distancia euclidiana corregida por aspecto para medir velocidad real
            const aspect = window.innerWidth / window.innerHeight;
            const dx = (x - prevMouseX) * aspect; // Corregimos X por aspecto
            const dy = y - prevMouseY;

            const dist = Math.sqrt(dx*dx + dy*dy);
            const strength = Math.min(dist * 150.0, 4.0);

            if (strength > 0.05) {
                addDisturbance(x, y, strength);
            }
            prevMouseX = x; prevMouseY = y;
        });

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            uniforms.u_time.value += 0.005;
            renderer.render(scene, camera);
        }
        animate();

        // Parallax Profile
        const profile = document.getElementById('profile');
        document.addEventListener('mousemove', (e) => {
            const x = (window.innerWidth / 2 - e.clientX) / 30;
            const y = (window.innerHeight / 2 - e.clientY) / 30;
            profile.style.transform = `translate(${x}px, ${y}px)`;
        });

    </script>
</body>
</html>
